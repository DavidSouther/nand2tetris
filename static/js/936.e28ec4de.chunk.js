"use strict";(self.webpackChunk_nand2tetris_web=self.webpackChunk_nand2tetris_web||[]).push([[936],{6936:function(n,t,a){a.r(t),a.d(t,{ChipProjects:function(){return O},default:function(){return I},loadSolutions:function(){return N},loaders:function(){return T}});var o={};a.r(o),a.d(o,{SOLS:function(){return l},loadSolutions:function(){return b}});var e={};a.r(e),a.d(e,{SOLS:function(){return A},loadSolutions:function(){return m}});var u={};a.r(u),a.d(u,{SOLS:function(){return y},loadSolutions:function(){return x}});var r={};a.r(r),a.d(r,{SOLS:function(){return p},loadSolutions:function(){return M}});var d=a(1092),s=a(7791),i=a(9956),l={Not:{"Not.hdl":"// Not gate: out = not in\n\nCHIP Not {\n    IN in;\n    OUT out;\n\n    PARTS:\n    Nand (a=in, b=in, out=out);\n}"},And:{"And.hdl":"CHIP And {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Nand(a=a, b=b, out=x);\n    Not(in=x, out=out);\n}"},Or:{"Or.hdl":"CHIP Or {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Not  (in=a, out=nota);\n    Not  (in=b, out=notb);\n    Nand (a=nota, b=notb, out=out);\n}"},XOr:{"XOr.hdl":"CHIP XOr {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Not (in=a, out=nota);\n    Not (in=b, out=notb);\n    And (a=nota, b=b, out=and1);\n    And (a=a, b=notb, out=and2);\n    Or  (a=and1, b=and2, out=out);\n}"},Mux:{"Mux.hdl":"CHIP Mux {\n    IN a, b, sel;\n    OUT out;\n\n    PARTS:\n    Not (in=sel, out=notsel);\n    And (a=a,    b=notsel, out=and1);\n    And (a=b,    b=sel,    out=and2);\n    Or  (a=and1, b=and2,   out=out);\n}"},DMux:{"DMux.hdl":"CHIP DMux {\n    IN in, sel;\n    OUT a, b;\n\n    PARTS:\n    Not(in=sel, out=notSel);\n    And(a=in, b=notSel, out=a);\n    And(a=in, b=sel, out=b);\n}"},Not16:{"Not16.hdl":"// 16-bit Not gate: for i=0..15: out[i] = not in[i]\n\nCHIP Not16 {\n   IN in[16];\n   OUT out[16];\n\n   PARTS:\n   Not (in=in[0],  out=out[0]);\n   Not (in=in[1],  out=out[1]);\n   Not (in=in[2],  out=out[2]);\n   Not (in=in[3],  out=out[3]);\n   Not (in=in[4],  out=out[4]);\n   Not (in=in[5],  out=out[5]);\n   Not (in=in[6],  out=out[6]);\n   Not (in=in[7],  out=out[7]);\n   Not (in=in[8],  out=out[8]);\n   Not (in=in[9],  out=out[9]);\n   Not (in=in[10], out=out[10]);\n   Not (in=in[11], out=out[11]);\n   Not (in=in[12], out=out[12]);\n   Not (in=in[13], out=out[13]);\n   Not (in=in[14], out=out[14]);\n   Not (in=in[15], out=out[15]);\n}"},And16:{"And16.hdl":"CHIP And16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    And (a=a[0],  b=b[0],  out=out[0]);\n    And (a=a[1],  b=b[1],  out=out[1]);\n    And (a=a[2],  b=b[2],  out=out[2]);\n    And (a=a[3],  b=b[3],  out=out[3]);\n    And (a=a[4],  b=b[4],  out=out[4]);\n    And (a=a[5],  b=b[5],  out=out[5]);\n    And (a=a[6],  b=b[6],  out=out[6]);\n    And (a=a[7],  b=b[7],  out=out[7]);\n    And (a=a[8],  b=b[8],  out=out[8]);\n    And (a=a[9],  b=b[9],  out=out[9]);\n    And (a=a[10], b=b[10], out=out[10]);\n    And (a=a[11], b=b[11], out=out[11]);\n    And (a=a[12], b=b[12], out=out[12]);\n    And (a=a[13], b=b[13], out=out[13]);\n    And (a=a[14], b=b[14], out=out[14]);\n    And (a=a[15], b=b[15], out=out[15]);\n}"},Or16:{"Or16.hdl":"CHIP Or16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    Or (a=a[0],  b=b[0],  out=out[0]);\n    Or (a=a[1],  b=b[1],  out=out[1]);\n    Or (a=a[2],  b=b[2],  out=out[2]);\n    Or (a=a[3],  b=b[3],  out=out[3]);\n    Or (a=a[4],  b=b[4],  out=out[4]);\n    Or (a=a[5],  b=b[5],  out=out[5]);\n    Or (a=a[6],  b=b[6],  out=out[6]);\n    Or (a=a[7],  b=b[7],  out=out[7]);\n    Or (a=a[8],  b=b[8],  out=out[8]);\n    Or (a=a[9],  b=b[9],  out=out[9]);\n    Or (a=a[10], b=b[10], out=out[10]);\n    Or (a=a[11], b=b[11], out=out[11]);\n    Or (a=a[12], b=b[12], out=out[12]);\n    Or (a=a[13], b=b[13], out=out[13]);\n    Or (a=a[14], b=b[14], out=out[14]);\n    Or (a=a[15], b=b[15], out=out[15]);\n}"},Mux16:{"Mux16.hdl":"CHIP Mux16 {\n    IN a[16], b[16], sel;\n    OUT out[16];\n\n    PARTS:\n     Mux(a=a[0],  b=b[0],  sel=sel, out=out[0]);\n     Mux(a=a[1],  b=b[1],  sel=sel, out=out[1]);\n     Mux(a=a[2],  b=b[2],  sel=sel, out=out[2]);\n     Mux(a=a[3],  b=b[3],  sel=sel, out=out[3]);\n     Mux(a=a[4],  b=b[4],  sel=sel, out=out[4]);\n     Mux(a=a[5],  b=b[5],  sel=sel, out=out[5]);\n     Mux(a=a[6],  b=b[6],  sel=sel, out=out[6]);\n     Mux(a=a[7],  b=b[7],  sel=sel, out=out[7]);\n     Mux(a=a[8],  b=b[8],  sel=sel, out=out[8]);\n     Mux(a=a[9],  b=b[9],  sel=sel, out=out[9]);\n     Mux(a=a[10], b=b[10], sel=sel, out=out[10]);\n     Mux(a=a[11], b=b[11], sel=sel, out=out[11]);\n     Mux(a=a[12], b=b[12], sel=sel, out=out[12]);\n     Mux(a=a[13], b=b[13], sel=sel, out=out[13]);\n     Mux(a=a[14], b=b[14], sel=sel, out=out[14]);\n     Mux(a=a[15], b=b[15], sel=sel, out=out[15]);\n}"},Mux4Way16:{"Mux4Way16.hdl":"CHIP Mux4Way16 {\n    IN a[16], b[16], c[16], d[16], sel[2];\n    OUT out[16];\n\n    PARTS:\n    Mux16(a=a,  b=b,  sel=sel[0], out=ab);\n    Mux16(a=c,  b=d,  sel=sel[0], out=cd);\n    Mux16(a=ab, b=cd, sel=sel[1], out=out);\n\n// Alternate implementation\n//\n// Some students make a Mux4Way chip and apply it 16 times as in Not16.\n}"},Mux8Way16:{"Mux8Way16.hdl":"CHIP Mux8Way16 {\n    IN a[16], b[16], c[16], d[16],\n       e[16], f[16], g[16], h[16],\n       sel[3];\n    OUT out[16];\n\n    PARTS:\n    // Binary tree of 2-way multiplexors\n    Mux16 (a=a,    b=b,    sel=sel[0], out=ab);\n    Mux16 (a=c,    b=d,    sel=sel[0], out=cd);\n    Mux16 (a=e,    b=f,    sel=sel[0], out=ef);\n    Mux16 (a=g,    b=h,    sel=sel[0], out=gh);\n    Mux16 (a=ab,   b=cd,   sel=sel[1], out=abcd);\n    Mux16 (a=ef,   b=gh,   sel=sel[1], out=efgh);\n    Mux16 (a=abcd, b=efgh, sel=sel[2], out=out);\n\n\n// Alternate implementation\n//\n// This implementation replaces the upper two layers of the\n// tree with 4-way multiplexors.\n/*\n    Mux4Way16 (a=a, b=b, c=c, d=d, sel=sel[0..1], out=abcd);\n    Mux4Way16 (a=e, b=f, c=g, d=h, sel=sel[0..1], out=efgh);\n    Mux16     (a=abcd, b=efgh, sel=sel[2], out=out);\n*/\n\n// Alternate implementation\n//\n// Some students make a Mux8Way chip and apply it 16 times as in Not16.\n}"},DMux4Way:{"DMux4Way.hdl":"CHIP DMux4Way {\n    IN in, sel[2];\n    OUT a, b, c, d;\n\n    PARTS:\n    DMux (in=in, sel=sel[1], a=ab, b=cd);\n    DMux (in=ab, sel=sel[0], a=a, b=b);\n    DMux (in=cd, sel=sel[0], a=c, b=d);\n\n// Alternate implementation, using a canonical representation.\n/*\n    Not (in=sel[0], out=notSel0);\n    Not (in=sel[1], out=notSel1);\n    And (a=notSel1, b=notSel0, out=selA);\n    And (a=notSel1, b=sel[0],  out=selB);\n    And (a=sel[1],  b=notSel0, out=selC);\n    And (a=sel[1],  b=sel[0],  out=selD);\n    And (a=selA, b=in, out=a);\n    And (a=selB, b=in, out=b);\n    And (a=selC, b=in, out=c);\n    And (a=selD, b=in, out=d);\n*/\n}"},DMux8Way:{"DMux8Way.hdl":"CHIP DMux8Way {\n    IN in, sel[3];\n    OUT a, b, c, d, e, f, g, h;\n\n    PARTS:\n    // Binary tree of demultiplexors.\n    DMux (sel=sel[2], in=in,   a=abcd, b=efgh);\n    DMux (sel=sel[1], in=abcd, a=ab,   b=cd);\n    DMux (sel=sel[1], in=efgh, a=ef,   b=gh);\n    DMux (sel=sel[0], in=ab,   a=a,    b=b);\n    DMux (sel=sel[0], in=cd,   a=c,    b=d);\n    DMux (sel=sel[0], in=ef,   a=e,    b=f);\n    DMux (sel=sel[0], in=gh,   a=g,    b=h);\n\n// Alternate implementation\n//\n// Replace the final two layers of the binary tree with\n// 4-way demultiplexors.\n/*\n    DMux     (sel=sel[2],    in=in,   a=abcd,   b=efgh);\n    DMux4Way (sel=sel[0..1], in=abcd, a=a, b=b, c=c, d=d);\n    DMux4Way (sel=sel[0..1], in=efgh, a=e, b=f, c=g, d=h);\n*/\n\n// Alternate implementation\n//\n// The binary tree of demultiplexors implementation with\n// the demultiplexors in canonical form.\n/*\n    Not (in=sel[0], out=notSel0);\n    Not (in=sel[1], out=notSel1);\n    Not (in=sel[2], out=notSel2);\n\n    And (a=in,   b=notSel2, out=abcd);\n    And (a=in,   b=sel[2],  out=efgh);\n\n    And (a=abcd, b=notSel1, out=ab);\n    And (a=abcd, b=sel[1],  out=cd);\n    And (a=efgh, b=notSel1, out=ef);\n    And (a=efgh, b=sel[1],  out=gh);\n\n    And (a=ab,   b=notSel0, out=a);\n    And (a=ab,   b=sel[0],  out=b);\n    And (a=cd,   b=notSel0, out=c);\n    And (a=cd,   b=sel[0],  out=d);\n    And (a=ef,   b=notSel0, out=e);\n    And (a=ef,   b=sel[0],  out=f);\n    And (a=gh,   b=notSel0, out=g);\n    And (a=gh,   b=sel[0],  out=h);\n*/\n}"},Or8Way:{"Or8Way.hdl":"CHIP Or8Way {\n    IN in[8];\n    OUT out;\n\n    PARTS:\n    Or (a=in[0], b=in[1], out=or01);\n    Or (a=in[2], b=in[3], out=or23);\n    Or (a=in[4], b=in[5], out=or45);\n    Or (a=in[6], b=in[7], out=or67);\n    Or (a=or01, b=or23, out=or0123);\n    Or (a=or45, b=or67, out=or4567);\n    Or (a=or0123, b=or4567, out=out);\n}"}};function b(n){return c.apply(this,arguments)}function c(){return(c=(0,s.Z)((0,d.Z)().mark((function n(t){return(0,d.Z)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,t.pushd("/projects/01");case 2:return n.next=4,(0,i.mc)(t,l);case 4:return n.next=6,t.popd();case 6:case"end":return n.stop()}}),n)})))).apply(this,arguments)}var A={HalfAdder:{"HalfAdder.hdl":"CHIP HalfAdder {\n    IN a, b;    // 1-bit inputs\n    OUT sum,    // Right bit of a + b \n        carry;  // Left bit of a + b\n\n    PARTS:\n    Xor (a=a, b=b, out=sum);\n    And (a=a, b=b, out=carry);\n}"},FullAdder:{"FullAdder.hdl":"CHIP FullAdder {\n    IN a, b, c;  // 1-bit inputs\n    OUT sum,     // Right bit of a + b + c\n        carry;   // Left bit of a + b + c\n\n    PARTS:\n    HalfAdder (a=a, b=b, sum=sum1, carry=carry1);\n    HalfAdder (a=c, b=sum1, sum=sum, carry=carry2);\n    Or        (a=carry1, b=carry2, out=carry);\n\n// Alternate implementation.\n// The first implementation is the way FullAdder is described in the book.\n// This implementation is elegant, but slightly less efficient. There is\n// no reason to prefer either implementation over the other.\n/*\n    HalfAdder (a=a, b=b, sum=sum1, carry=carry1);\n    HalfAdder (a=c, b=sum1, sum=sum, carry=carry2);\n    HalfAdder (a=carry1, b=carry2, out=carry);\n*/\n\n// Alternate implementation using less abstraction.\n// Direct implementation without using half-adders,\n// as mentioned in the book.\n/*\n    Xor (a=a, b=b, out=abSum);\n    And (a=a, b=b, out=abCarry);\n    Xor (a=abSum, b=c, out=sum);\n    And (a=abSum, b=c, out=abcCarry);\n    Or  (a=abCarry, b=abcCarry, out=carry);\n*/\n}"},Add16:{"Add16.hdl":"CHIP Add16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    FullAdder (a=a[0],  b=b[0],         sum=out[0],  carry=c1);\n    FullAdder (a=a[1],  b=b[1],  c=c1,  sum=out[1],  carry=c2);\n    FullAdder (a=a[2],  b=b[2],  c=c2,  sum=out[2],  carry=c3);\n    FullAdder (a=a[3],  b=b[3],  c=c3,  sum=out[3],  carry=c4);\n    FullAdder (a=a[4],  b=b[4],  c=c4,  sum=out[4],  carry=c5);\n    FullAdder (a=a[5],  b=b[5],  c=c5,  sum=out[5],  carry=c6);\n    FullAdder (a=a[6],  b=b[6],  c=c6,  sum=out[6],  carry=c7);\n    FullAdder (a=a[7],  b=b[7],  c=c7,  sum=out[7],  carry=c8);\n    FullAdder (a=a[8],  b=b[8],  c=c8,  sum=out[8],  carry=c9);\n    FullAdder (a=a[9],  b=b[9],  c=c9,  sum=out[9],  carry=c10);\n    FullAdder (a=a[10], b=b[10], c=c10, sum=out[10], carry=c11);\n    FullAdder (a=a[11], b=b[11], c=c11, sum=out[11], carry=c12);\n    FullAdder (a=a[12], b=b[12], c=c12, sum=out[12], carry=c13);\n    FullAdder (a=a[13], b=b[13], c=c13, sum=out[13], carry=c14);\n    FullAdder (a=a[14], b=b[14], c=c14, sum=out[14], carry=c15);\n    FullAdder (a=a[15], b=b[15], c=c15, sum=out[15]);\n\n// Alternate implementation\n// Both implementations are described in the text. There is no reason\n// to prefer either implementation over the other.\n/*\n    FullAdder (a=a[0],  b=b[0],  c=false, sum=out[0],  carry=c0);\n    FullAdder (a=a[1],  b=b[1],  c=c0,    sum=out[1],  carry=c1);\n    ...\n*/\n}"},Inc16:{"Inc16.hdl":"CHIP Inc16 {\n    IN in[16];\n    OUT out[16];\n\n    PARTS:\n    Add16 (a=in, b[0]=true, b[1..15]=false, out=out);\n    \n// Alternative implementation. Unset bits are explicitly false.\n// Add16 (a=in, b[0]=true, out=out);\n\n// Alternate implementation using less abstraction.\n// The first implementation is how Inc16 is described in the text.\n// This is the classical implementation. \n/*\n    HalfAdder (a=in[0], b=true, sum=out[0],  carry=c0);\n    HalfAdder (a=in[1], b=c0,   sum=out[1],  carry=c1);\n    HalfAdder (a=in[2], b=c1,   sum=out[2],  carry=c2);\n    HalfAdder (a=in[3], b=c2,   sum=out[3],  carry=c3);\n    HalfAdder (a=in[4], b=c3,   sum=out[4],  carry=c4);\n    HalfAdder (a=in[5], b=c4,   sum=out[5],  carry=c5);\n    HalfAdder (a=in[6], b=c5,   sum=out[6],  carry=c6);\n    HalfAdder (a=in[7], b=c6,   sum=out[7],  carry=c7);\n    HalfAdder (a=in[8], b=c7,   sum=out[8],  carry=c8);\n    HalfAdder (a=in[9], b=c8,   sum=out[9],  carry=c9);\n    HalfAdder (a=in[10],b=c9,   sum=out[10], carry=c10);\n    HalfAdder (a=in[11],b=c10,  sum=out[11], carry=c11);\n    HalfAdder (a=in[12],b=c11,  sum=out[12], carry=c12);\n    HalfAdder (a=in[13],b=c12,  sum=out[13], carry=c13);\n    HalfAdder (a=in[14],b=c13,  sum=out[14], carry=c14);\n    HalfAdder (a=in[15],b=c14,  sum=out[15]);\n*/\n}"},AluNoStat:{"AluNoStat.hdl":"CHIP ALU {\n    IN  \n        x[16], y[16],  // 16-bit inputs        \n        zx, // zero the x input?\n        nx, // negate the x input?\n        zy, // zero the y input?\n        ny, // negate the y input?\n        f,  // compute out = x + y (if 1) or x & y (if 0)\n        no; // negate the out output?\n\n    OUT \n        out[16]; // 16-bit output\n\n    PARTS:\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out=out);\n    // x input processing, controlled by the 'zx' and 'nx' bits.\n    // When 'zx' is false, x is zeroed. 'nx' will select the negation of the\n    // possibly zeroed x input, and make it avaialble as 'xbus'.\n    Mux16 (sel=zx, a=x, b=false, out=xzero); \n    Not16 (in=xzero, out=notx);       \n    Mux16 (sel=nx, a=xzero, b=notx, out=xbus);\n\n    // y input processing, controlled by the 'zy' and 'ny' bits.\n    // When 'zy' is false, y is zeroed. 'ny' will select the negation of the\n    // possibly zeroed y input, and make it avaialble as 'ybus'.\n    Mux16(sel=zy, a=y, b=false, out=yzero);\n    Not16(in=yzero, out=noty);\n    Mux16(sel=ny, a=yzero, b=noty, out=ybus);\n\n    // Compute both functions and select based on the 'f' bit\n    And16(a=xbus, b=ybus, out=fbusand);\n    Add16(a=xbus, b=ybus, out=fbusadd);\n    Mux16(sel=f, a=fbusand, b=fbusadd, out=outbus);\n\n    // Output inversion, controlled by the 'no' bit\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out=out);\n}"},ALU:{"ALU.hdl":"CHIP ALU {\n    IN  \n        x[16], y[16],  // 16-bit inputs        \n        zx, // zero the x input?\n        nx, // negate the x input?\n        zy, // zero the y input?\n        ny, // negate the y input?\n        f,  // compute out = x + y (if 1) or x & y (if 0)\n        no; // negate the out output?\n\n    OUT \n        out[16], // 16-bit output\n        zr, // 1 if (out == 0), 0 otherwise\n        ng; // 1 if (out < 0),  0 otherwise\n\n    PARTS:\n    // x input processing, controlled by the 'zx' and 'nx' bits.\n    // When 'zx' is false, x is zeroed. 'nx' will select the negation of the\n    // possibly zeroed x input, and make it avaialble as 'xbus'.\n    Mux16 (sel=zx, a=x, b=false, out=xzero); \n    Not16 (in=xzero, out=notx);       \n    Mux16 (sel=nx, a=xzero, b=notx, out=xbus);\n\n    // y input processing, controlled by the 'zy' and 'ny' bits.\n    // When 'zy' is false, y is zeroed. 'ny' will select the negation of the\n    // possibly zeroed y input, and make it avaialble as 'ybus'.\n    Mux16(sel=zy, a=y, b=false, out=yzero);\n    Not16(in=yzero, out=noty);\n    Mux16(sel=ny, a=yzero, b=noty, out=ybus);\n\n    // Compute both functions and select based on the 'f' bit\n    And16(a=xbus, b=ybus, out=fbusand);\n    Add16(a=xbus, b=ybus, out=fbusadd);\n    Mux16(sel=f, a=fbusand, b=fbusadd, out=outbus);\n\n    // Output inversion, controlled by the 'no' bit\n    // 'out' bit 15 is the 'ng' flag\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out[15]=ng, out[0..7]=zr1, out[8..15]=zr2, out=out);\n\n    // Compute the zr and nz flags\n    Or8Way(in=zr1, out=zra);\n    Or8Way(in=zr2, out=zrb);\n    Or(a=zra, b=zrb, out=zror);\n    Not(in=zror, out=zr);\n}"}};function m(n){return h.apply(this,arguments)}function h(){return(h=(0,s.Z)((0,d.Z)().mark((function n(t){return(0,d.Z)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,t.pushd("/projects/02");case 2:return n.next=4,(0,i.mc)(t,A);case 4:return n.next=6,t.popd();case 6:case"end":return n.stop()}}),n)})))).apply(this,arguments)}var y={Bit:{"Bit.hdl":"CHIP Bit {\n    IN in, load;\n    OUT out;\n\n    PARTS:\n    \n    Mux (a=dffOut, b=in, sel=load, out=muxOut);\n    DFF (in=muxOut, out=dffOut, out=out);\n}"},Register:{"Register.hdl":"CHIP Register {\n    IN in[16], load;\n    OUT out[16];\n\n    PARTS:\n    Bit (in=in[0],  load=load, out=out[0]);\n    Bit (in=in[1],  load=load, out=out[1]);\n    Bit (in=in[2],  load=load, out=out[2]);\n    Bit (in=in[3],  load=load, out=out[3]);\n    Bit (in=in[4],  load=load, out=out[4]);\n    Bit (in=in[5],  load=load, out=out[5]);\n    Bit (in=in[6],  load=load, out=out[6]);\n    Bit (in=in[7],  load=load, out=out[7]);\n    Bit (in=in[8],  load=load, out=out[8]);\n    Bit (in=in[9],  load=load, out=out[9]);\n    Bit (in=in[10], load=load, out=out[10]);\n    Bit (in=in[11], load=load, out=out[11]);\n    Bit (in=in[12], load=load, out=out[12]);\n    Bit (in=in[13], load=load, out=out[13]);\n    Bit (in=in[14], load=load, out=out[14]);\n    Bit (in=in[15], load=load, out=out[15]);\n}"},PC:{"PC.hdl":"CHIP PC {\n    IN in[16], load, inc, reset;\n    OUT out[16];\n\n    PARTS:\n    // The internal 'self' pin tracks the current state of the PC. The 'pc' pin\n    // tracks the next value of the PC. Based on 'inc', 'lost', and 'reset',\n    // one of 'self', 'pc', and 'false' will be put on 'next' and used as the\n    // input value of the Register, which will always load that value and write\n    // its current value to 'self'.\n\n    Inc16 (in=self, out=pc);\n\n    Mux16 (sel=inc,   a=self, b=pc,    out=pin0);\n    Mux16 (sel=load,  a=pin0, b=in,    out=pin1);\n    Mux16 (sel=reset, a=pin1, b=false, out=next);\n\n    Register (in=next, load=true, out=out, out=self);\n}"},RAM8:{"RAM8.hdl":"CHIP RAM8 {\n    IN in[16], load, address[3];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address,\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The registers proper\n    Register (in=in, load=load1, out=reg1);\n    Register (in=in, load=load2, out=reg2);\n    Register (in=in, load=load3, out=reg3);\n    Register (in=in, load=load4, out=reg4);\n    Register (in=in, load=load5, out=reg5);\n    Register (in=in, load=load6, out=reg6);\n    Register (in=in, load=load7, out=reg7);\n    Register (in=in, load=load8, out=reg8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=reg1,\n        b=reg2,\n        c=reg3,\n        d=reg4,\n        e=reg5,\n        f=reg6,\n        g=reg7,\n        h=reg8,\n        sel=address,\n        out=out\n    );\n}"},RAM64:{"RAM64.hdl":"CHIP RAM64 {\n    IN in[16], load, address[6];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[3..5],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The child blocks\n    RAM8 (in=in, load=load1, address=address[0..2], out=ram1);\n    RAM8 (in=in, load=load2, address=address[0..2], out=ram2);\n    RAM8 (in=in, load=load3, address=address[0..2], out=ram3);\n    RAM8 (in=in, load=load4, address=address[0..2], out=ram4);\n    RAM8 (in=in, load=load5, address=address[0..2], out=ram5);\n    RAM8 (in=in, load=load6, address=address[0..2], out=ram6);\n    RAM8 (in=in, load=load7, address=address[0..2], out=ram7);\n    RAM8 (in=in, load=load8, address=address[0..2], out=ram8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        e=ram5,\n        f=ram6,\n        g=ram7,\n        h=ram8,\n        sel=address[3..5],\n        out=out\n    );\n}"},RAM512:{"RAM512.hdl":"CHIP RAM512 {\n    IN in[16], load, address[9];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[6..8],\n        a=loada,\n        b=loadb,\n        c=loadc,\n        d=loadd,\n        e=loade,\n        f=loadf,\n        g=loadg,\n        h=loadh\n    );\n\n    // The child blocks\n    RAM64 (in=in, load=loada, address=address[0..5], out=rama);\n    RAM64 (in=in, load=loadb, address=address[0..5], out=ramb);\n    RAM64 (in=in, load=loadc, address=address[0..5], out=ramc);\n    RAM64 (in=in, load=loadd, address=address[0..5], out=ramd);\n    RAM64 (in=in, load=loade, address=address[0..5], out=rame);\n    RAM64 (in=in, load=loadf, address=address[0..5], out=ramf);\n    RAM64 (in=in, load=loadg, address=address[0..5], out=ramg);\n    RAM64 (in=in, load=loadh, address=address[0..5], out=ramh);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=rama,\n        b=ramb,\n        c=ramc,\n        d=ramd,\n        e=rame,\n        f=ramf,\n        g=ramg,\n        h=ramh,\n        sel=address[6..8],\n        out=out\n    );\n}"},RAM4k:{"RAM4k.hdl":"CHIP RAM4K {\n    IN in[16], load, address[12];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[9..11],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The child blocks\n    RAM512 (in=in, load=load1, address=address[0..8], out=ram1);\n    RAM512 (in=in, load=load2, address=address[0..8], out=ram2);\n    RAM512 (in=in, load=load3, address=address[0..8], out=ram3);\n    RAM512 (in=in, load=load4, address=address[0..8], out=ram4);\n    RAM512 (in=in, load=load5, address=address[0..8], out=ram5);\n    RAM512 (in=in, load=load6, address=address[0..8], out=ram6);\n    RAM512 (in=in, load=load7, address=address[0..8], out=ram7);\n    RAM512 (in=in, load=load8, address=address[0..8], out=ram8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        e=ram5,\n        f=ram6,\n        g=ram7,\n        h=ram8,\n        sel=address[9..11],\n        out=out\n    );\n}"},RAM16k:{"RAM16k.hdl":"CHIP RAM16K {\n    IN in[16], load, address[14];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 4 load channels\n    DMux4Way(\n        in=load,\n        sel=address[12..13],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4\n    );\n\n    // The child blocks\n    RAM4K (in=in, load=load1, address=address[0..11], out=ram1);\n    RAM4K (in=in, load=load2, address=address[0..11], out=ram2);\n    RAM4K (in=in, load=load3, address=address[0..11], out=ram3);\n    RAM4K (in=in, load=load4, address=address[0..11], out=ram4);\n\n    // The output logic is a simple muxer\n    Mux4Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        sel=address[12..13],\n        out=out\n    );\n}"}};function x(n){return f.apply(this,arguments)}function f(){return(f=(0,s.Z)((0,d.Z)().mark((function n(t){return(0,d.Z)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,t.pushd("/projects/03");case 2:return n.next=4,(0,i.mc)(t,y);case 4:return n.next=6,t.popd();case 6:case"end":return n.stop()}}),n)})))).apply(this,arguments)}var p={Memory:{"Memory.hdl":"CHIP Memory {\n    IN in[16], load, address[15];\n    OUT out[16];\n\n    PARTS:\n    DMux4Way (in=load, sel=address[13..14], a=load0, b=load1, c=loadScreen);\n    Or       (a=load0, b=load1, out=loadRAM);\n    RAM16K   (in=in, load=loadRAM, address=address[0..13], out=ramOut);\n    Screen   (in=in, load=loadScreen, address=address[0..12], out=screenOut);\n\n    // check if keyboard address - 0x6000 = 110 0000 0000 0000\n    And    (a=address[13], b=address[14], out=and1314);\n    Or8Way (in=address[0..7], out=or0to7);\n    Or8Way (in=address[5..12], out=or5to12);\n    Or     (a=or0to7, b=or5to12, out=or0to12);\n    Not    (in=or0to12, out=zero0to12);\n    And    (a=zero0to12, b=and1314, out=keyAddress);\n\n    // if keyboard address, output keyboard contents\n    Keyboard  (out=key);\n    Mux16     (a=false, b=key, sel=keyAddress, out=keyOut);\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n\n// Alternate implementation for keyboard decoding.\n/*\n    // check if keyboard address - 0x6000 = 110 0000 0000 0000\n    // The output Mux4Way16 selects the range 0x6000 - 0x7FFF (the 1's). \n    // Decode xx0 0000 0000 0000 so that only 0x6000 responds within\n    // this range.\n    Or8Way (in=address[0..7], out=or0to7);\n    Or8Way (in[0]=or0to7, in[1..7]=address[6..12], out=or0to12);\n    Not (in=or0to12, out=keyAddress);\n\n    // if keyboard address, output keyboard contents\n    Keyboard (out=key);\n    Mux16 (a=false, b=key, sel=keyAddress, out=keyOut);\n\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n*/\n\n\n// Alternate implementation.\n//\n// The book says \"Access to any address>24576 (0x6000) is invalid.\"  It can be\n// argued that any access to an invalid address may return a don't-care value.\n// The current keyboard value is as good a don't-care as any, so there is no\n// need to decode the specific address.\n//\n// Some argue that this is poor engineering practice.\n// Fully decoding I/O addresses should be encouraged.\n/*\n    PARTS:\n    DMux4Way (in=load, sel=address[13..14], a=load0, b=load1, c=loadScreen);\n    Or (a=load0, b=load1, out=loadRAM);\n    RAM16K (in=in, load=loadRAM, address=address[0..13], out=ramOut);\n    Screen (in=in, load=loadScreen, address=address[0..12], out=screenOut);\n    Keyboard (out=keyOut);\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n*/\n}"},CPU:{"CPU.hdl":"CHIP CPU {\n    IN  inM[16],         // M value input  (M = contents of RAM[A])\n        instruction[16], // Instruction for execution\n        reset;           // Signals whether to re-start the current\n                         // program (reset==1) or continue executing\n                         // the current program (reset==0).\n\n    OUT outM[16],        // M value output\n        writeM,          // Write to M? \n        addressM[15],    // Address in data memory (of M)\n        pc[15];          // address of next instruction\n\n    PARTS:\n\n    // See Figure 5.9 for a schematic of the CPU.\n\n    // From figure 5.9, set all control bits from incoming instruction. \n    Not(in=instruction[15], out=aInstruction);\n    Mux16(\n        b=false,\n        a=instruction,\n        sel=aInstruction,\n        out[15]=cInst,\n        out[12]=a,\n        out[11]=c1,\n        out[10]=c2,\n        out[9]=c3,\n        out[8]=c4,\n        out[7]=c5,\n        out[6]=c6,\n        out[5]=d1,\n        out[4]=writeD,\n        out[3]=writeM,\n        out[0..2]=jump\n    );\n\n    // Register A will be filled from either the instruction line or the ALU,\n    // based on the aInstruction bit (bit 15 of the instruction).\n    Mux16(a=alu, b=instruction, sel=aInstruction, out=regA);\n\n    // Only read 15 bits of memory address into register A.\n    Or(a=aInstruction, b=d1, out=setA);\n    ARegister(in=regA, in[15]=false, load=setA, out[0..14]=addressM, out=A);\n\n    // D register is loaded from the ALU when d2 is set.\n    DRegister(in=alu, load=writeD, out=D);\n\n    // Fill the A bus line from either the A register or Memory, based on\n    // instruction bit a (12).\n    Mux16(a=A, b=inM, sel=a, out=AM);\n\n    // ALU control bits are mapped directly in C instructions when in c mode.\n    // If aInstruction is 0, c instructions are 0, and ALU will output 0.\n    ALU(\n        x=D,\n        y=AM,\n        zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6,\n        out=alu,\n        out=outM,\n        zr=zr, ng=ng\n    );\n    \n    // Jump\n    Not(in=ng, out=nng);\n    Not(in=zr, out=nzr);\n    And(a=nng, b=nzr, out=pt); // Positive is not negative and not zero\n\n    And(a=jump[2], b=ng, out=jlt);\n    And(a=jump[1], b=zr, out=jeq);\n    And(a=jump[0], b=pt, out=jgt);\n\n    And(a=jgt, b=jeq, out=jge);\n    And(a=jlt, b=jeq, out=jle);\n    And(a=jgt, b=jlt, out=jne);\n\n    Or8Way(\n        in[0]=jgt,\n        in[1]=jeq,\n        in[2]=jge,\n        in[3]=jlt,\n        in[4]=jne,\n        in[5]=jle,\n        out=jmpi,\n    );\n\n    And(a=jmpi, b=cInst, out=jmp);\n\n    PC(in=A, load=jmp, reset=reset, inc=true, out[0..14]=pc);\n}"},Computer:{"Computer.hdl":"CHIP Computer {\n    IN reset;\n\n    PARTS:\n    CPU(\n        reset=reset,\n        inM=outM,\n        instruction=instruction,\n        outM=inM,\n        writeM=writeM,\n        addressM=addressM,\n        pc=pc\n    );\n\n    // ROM\n    ROM32K(\n        address=pc,\n        out=instruction\n    );\n\n    // RAM\n    Memory(\n        in=inM,\n        load=writeM,\n        address=addressM,\n        out=outM\n    );\n}"}};function M(n){return g.apply(this,arguments)}function g(){return(g=(0,s.Z)((0,d.Z)().mark((function n(t){return(0,d.Z)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,t.pushd("/projects/05");case 2:return n.next=4,(0,i.mc)(t,p);case 4:return n.next=6,t.popd();case 6:case"end":return n.stop()}}),n)})))).apply(this,arguments)}var O={"01":o,"02":e,"03":u,"05":r},R=!1,N=function(){var n=(0,s.Z)((0,d.Z)().mark((function n(t){return(0,d.Z)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(!R){n.next=2;break}return n.abrupt("return");case 2:return R=!0,n.next=5,b(t);case 5:return n.next=7,m(t);case 7:return n.next=9,x(t);case 9:return n.next=11,M(t);case 11:R=!1;case 12:case"end":return n.stop()}}),n)})));return function(t){return n.apply(this,arguments)}}(),T={loadSolutions:N},I=T}}]);
//# sourceMappingURL=936.e28ec4de.chunk.js.map