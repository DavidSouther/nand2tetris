{"version":3,"file":"static/js/936.e28ec4de.chunk.js","mappings":"koBAkBaA,EAAO,CAClBC,IAAK,CACH,UCpBe,uHDsBjBC,IAAK,CACH,UEvBe,gHFyBjBC,GAAI,CACF,SG1Be,uJH4BjBC,IAAK,CACH,UI7Be,yNJ+BjBC,IAAK,CACH,UKhCe,mNLkCjBC,KAAM,CACJ,WMnCe,6JNqCjBC,MAAO,CACL,YOtCe,6oBPwCjBC,MAAO,CACL,YQzCe,+tBR2CjBC,KAAM,CACJ,WS5Ce,8sBT8CjBC,MAAO,CACL,YU/Ce,o3BViDjBC,UAAW,CACT,gBWlDe,oVXoDjBC,UAAW,CACT,gBYrDe,+7BZuDjBC,SAAU,CACR,eaxDe,soBb0DjBC,SAAU,CACR,ec3De,qgDd6DjBC,OAAQ,CACN,ae9De,2UfkEZ,SAAeC,EAAtB,kC,8CAAO,WAA6BC,GAA7B,sFACCA,EAAGC,MAAM,gBADV,wBAECC,EAAAA,EAAAA,IAAMF,EAAIjB,GAFX,uBAGCiB,EAAGG,OAHJ,4C,sBgBlEA,ICSMpB,EAAO,CAClBqB,UAAW,CACT,gBDXe,kNCajBC,UAAW,CACT,gBCde,ohCDgBjBC,MAAO,CACL,YEjBe,s4CFmBjBC,MAAO,CACL,YGpBe,gyCHsBjBC,UAAW,CACT,gBIvBe,m9CJyBjBC,IAAK,CACH,UK1Be,msDL8BZ,SAAeV,EAAtB,kC,8CAAO,WAA6BC,GAA7B,sFACCA,EAAGC,MAAM,gBADV,wBAECC,EAAAA,EAAAA,IAAMF,EAAIjB,GAFX,uBAGCiB,EAAGG,OAHJ,4C,sBM9BA,ICWMpB,EAAO,CAClB2B,IAAK,CACH,UDbe,iKCejBC,SAAU,CACR,eChBe,kyBDkBjBC,GAAI,CACF,SEnBe,0qBFqBjBC,KAAM,CACJ,WGtBe,88BHwBjBC,MAAO,CACL,YIzBe,+mCJ2BjBC,OAAQ,CACN,aK5Be,wnCL8BjBC,MAAO,CACL,YM/Be,koCNiCjBC,OAAQ,CACN,aOlCe,kvBPsCZ,SAAelB,EAAtB,kC,8CAAO,WAA6BC,GAA7B,sFACCA,EAAGC,MAAM,gBADV,wBAECC,EAAAA,EAAAA,IAAMF,EAAIjB,GAFX,uBAGCiB,EAAGG,OAHJ,4C,sBQtCA,ICMMpB,EAAO,CAClBmC,OAAQ,CACN,aDRe,65ECUjBC,IAAK,CACH,UCXe,mmFDajBC,SAAU,CACR,eEde,+aFkBZ,SAAerB,EAAtB,kC,8CAAO,WAA6BC,GAA7B,sFACCA,EAAGC,MAAM,gBADV,wBAECC,EAAAA,EAAAA,IAAMF,EAAIjB,GAFX,uBAGCiB,EAAGG,OAHJ,4C,sBGXA,IAAMkB,EAAe,CAC1B,KAAMC,EACN,KAAMC,EACN,KAAMC,EACN,KAAMC,GAGJvB,GAAQ,EACCH,EAAa,yCAAG,WAAOC,GAAP,0EACvBE,EADuB,wDAE3BA,GAAQ,EAFmB,SAGrBoB,EAAyBtB,GAHJ,uBAIrBuB,EAAyBvB,GAJJ,uBAKrBwB,EAAyBxB,GALJ,wBAMrByB,EAAyBzB,GANJ,QAO3BE,GAAQ,EAPmB,4CAAH,sDAUbwB,EAAU,CACrB3B,cAAAA,GAGF,G","sources":["../../projects/src/solutions/project_01/index.ts","../../projects/src/solutions/project_01/01_not.ts","../../projects/src/solutions/project_01/02_and.ts","../../projects/src/solutions/project_01/03_or.ts","../../projects/src/solutions/project_01/04_xor.ts","../../projects/src/solutions/project_01/05_mux.ts","../../projects/src/solutions/project_01/06_dmux.ts","../../projects/src/solutions/project_01/07_not16.ts","../../projects/src/solutions/project_01/08_and16.ts","../../projects/src/solutions/project_01/09_or16.ts","../../projects/src/solutions/project_01/10_mux16.ts","../../projects/src/solutions/project_01/11_mux4way16.ts","../../projects/src/solutions/project_01/12_mux8way16.ts","../../projects/src/solutions/project_01/13_dmux4way.ts","../../projects/src/solutions/project_01/14_dmux8way.ts","../../projects/src/solutions/project_01/15_or8way.ts","../../projects/src/solutions/project_02/01_half_adder.ts","../../projects/src/solutions/project_02/index.ts","../../projects/src/solutions/project_02/02_full_adder.ts","../../projects/src/solutions/project_02/03_add16.ts","../../projects/src/solutions/project_02/04_inc16.ts","../../projects/src/solutions/project_02/05_alu_no_stat.ts","../../projects/src/solutions/project_02/06_alu.ts","../../projects/src/solutions/project_03/01_bit.ts","../../projects/src/solutions/project_03/index.ts","../../projects/src/solutions/project_03/02_register.ts","../../projects/src/solutions/project_03/03_pc.ts","../../projects/src/solutions/project_03/04_ram8.ts","../../projects/src/solutions/project_03/05_ram64.ts","../../projects/src/solutions/project_03/06_ram512.ts","../../projects/src/solutions/project_03/07_ram4k.ts","../../projects/src/solutions/project_03/08_ram16k.ts","../../projects/src/solutions/project_05/01_memory.ts","../../projects/src/solutions/project_05/index.ts","../../projects/src/solutions/project_05/02_cpu.ts","../../projects/src/solutions/project_05/03_computer.ts","../../projects/src/solutions/index.ts"],"sourcesContent":["import { FileSystem, reset } from \"@davidsouther/jiffies/lib/esm/fs.js\";\n\nimport * as Not from \"./01_not.js\";\nimport * as And from \"./02_and.js\";\nimport * as Or from \"./03_or.js\";\nimport * as Xor from \"./04_xor.js\";\nimport * as Mux from \"./05_mux.js\";\nimport * as DMux from \"./06_dmux.js\";\nimport * as Not16 from \"./07_not16.js\";\nimport * as And16 from \"./08_and16.js\";\nimport * as Or16 from \"./09_or16.js\";\nimport * as Mux16 from \"./10_mux16.js\";\nimport * as Mux4Way16 from \"./11_mux4way16.js\";\nimport * as Mux8Way16 from \"./12_mux8way16.js\";\nimport * as DMux4Way from \"./13_dmux4way.js\";\nimport * as DMux8Way from \"./14_dmux8way.js\";\nimport * as Or8Way from \"./15_or8way.js\";\n\nexport const SOLS = {\n  Not: {\n    \"Not.hdl\": Not.sol,\n  },\n  And: {\n    \"And.hdl\": And.sol,\n  },\n  Or: {\n    \"Or.hdl\": Or.sol,\n  },\n  XOr: {\n    \"XOr.hdl\": Xor.sol,\n  },\n  Mux: {\n    \"Mux.hdl\": Mux.sol,\n  },\n  DMux: {\n    \"DMux.hdl\": DMux.sol,\n  },\n  Not16: {\n    \"Not16.hdl\": Not16.sol,\n  },\n  And16: {\n    \"And16.hdl\": And16.sol,\n  },\n  Or16: {\n    \"Or16.hdl\": Or16.sol,\n  },\n  Mux16: {\n    \"Mux16.hdl\": Mux16.sol,\n  },\n  Mux4Way16: {\n    \"Mux4Way16.hdl\": Mux4Way16.sol,\n  },\n  Mux8Way16: {\n    \"Mux8Way16.hdl\": Mux8Way16.sol,\n  },\n  DMux4Way: {\n    \"DMux4Way.hdl\": DMux4Way.sol,\n  },\n  DMux8Way: {\n    \"DMux8Way.hdl\": DMux8Way.sol,\n  },\n  Or8Way: {\n    \"Or8Way.hdl\": Or8Way.sol,\n  },\n};\n\nexport async function loadSolutions(fs: FileSystem): Promise<void> {\n  await fs.pushd(\"/projects/01\");\n  await reset(fs, SOLS);\n  await fs.popd();\n}\n","export const sol = `// Not gate: out = not in\n\nCHIP Not {\n    IN in;\n    OUT out;\n\n    PARTS:\n    Nand (a=in, b=in, out=out);\n}`;\n","export const sol = `CHIP And {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Nand(a=a, b=b, out=x);\n    Not(in=x, out=out);\n}`;\n","export const sol = `CHIP Or {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Not  (in=a, out=nota);\n    Not  (in=b, out=notb);\n    Nand (a=nota, b=notb, out=out);\n}`;\n","export const sol = `CHIP XOr {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Not (in=a, out=nota);\n    Not (in=b, out=notb);\n    And (a=nota, b=b, out=and1);\n    And (a=a, b=notb, out=and2);\n    Or  (a=and1, b=and2, out=out);\n}`;\n","export const sol = `CHIP Mux {\n    IN a, b, sel;\n    OUT out;\n\n    PARTS:\n    Not (in=sel, out=notsel);\n    And (a=a,    b=notsel, out=and1);\n    And (a=b,    b=sel,    out=and2);\n    Or  (a=and1, b=and2,   out=out);\n}`;\n","export const sol = `CHIP DMux {\n    IN in, sel;\n    OUT a, b;\n\n    PARTS:\n    Not(in=sel, out=notSel);\n    And(a=in, b=notSel, out=a);\n    And(a=in, b=sel, out=b);\n}`;\n","export const sol = `// 16-bit Not gate: for i=0..15: out[i] = not in[i]\n\nCHIP Not16 {\n   IN in[16];\n   OUT out[16];\n\n   PARTS:\n   Not (in=in[0],  out=out[0]);\n   Not (in=in[1],  out=out[1]);\n   Not (in=in[2],  out=out[2]);\n   Not (in=in[3],  out=out[3]);\n   Not (in=in[4],  out=out[4]);\n   Not (in=in[5],  out=out[5]);\n   Not (in=in[6],  out=out[6]);\n   Not (in=in[7],  out=out[7]);\n   Not (in=in[8],  out=out[8]);\n   Not (in=in[9],  out=out[9]);\n   Not (in=in[10], out=out[10]);\n   Not (in=in[11], out=out[11]);\n   Not (in=in[12], out=out[12]);\n   Not (in=in[13], out=out[13]);\n   Not (in=in[14], out=out[14]);\n   Not (in=in[15], out=out[15]);\n}`;\n","export const sol = `CHIP And16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    And (a=a[0],  b=b[0],  out=out[0]);\n    And (a=a[1],  b=b[1],  out=out[1]);\n    And (a=a[2],  b=b[2],  out=out[2]);\n    And (a=a[3],  b=b[3],  out=out[3]);\n    And (a=a[4],  b=b[4],  out=out[4]);\n    And (a=a[5],  b=b[5],  out=out[5]);\n    And (a=a[6],  b=b[6],  out=out[6]);\n    And (a=a[7],  b=b[7],  out=out[7]);\n    And (a=a[8],  b=b[8],  out=out[8]);\n    And (a=a[9],  b=b[9],  out=out[9]);\n    And (a=a[10], b=b[10], out=out[10]);\n    And (a=a[11], b=b[11], out=out[11]);\n    And (a=a[12], b=b[12], out=out[12]);\n    And (a=a[13], b=b[13], out=out[13]);\n    And (a=a[14], b=b[14], out=out[14]);\n    And (a=a[15], b=b[15], out=out[15]);\n}`;\n","export const sol = `CHIP Or16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    Or (a=a[0],  b=b[0],  out=out[0]);\n    Or (a=a[1],  b=b[1],  out=out[1]);\n    Or (a=a[2],  b=b[2],  out=out[2]);\n    Or (a=a[3],  b=b[3],  out=out[3]);\n    Or (a=a[4],  b=b[4],  out=out[4]);\n    Or (a=a[5],  b=b[5],  out=out[5]);\n    Or (a=a[6],  b=b[6],  out=out[6]);\n    Or (a=a[7],  b=b[7],  out=out[7]);\n    Or (a=a[8],  b=b[8],  out=out[8]);\n    Or (a=a[9],  b=b[9],  out=out[9]);\n    Or (a=a[10], b=b[10], out=out[10]);\n    Or (a=a[11], b=b[11], out=out[11]);\n    Or (a=a[12], b=b[12], out=out[12]);\n    Or (a=a[13], b=b[13], out=out[13]);\n    Or (a=a[14], b=b[14], out=out[14]);\n    Or (a=a[15], b=b[15], out=out[15]);\n}`;\n","export const sol = `CHIP Mux16 {\n    IN a[16], b[16], sel;\n    OUT out[16];\n\n    PARTS:\n     Mux(a=a[0],  b=b[0],  sel=sel, out=out[0]);\n     Mux(a=a[1],  b=b[1],  sel=sel, out=out[1]);\n     Mux(a=a[2],  b=b[2],  sel=sel, out=out[2]);\n     Mux(a=a[3],  b=b[3],  sel=sel, out=out[3]);\n     Mux(a=a[4],  b=b[4],  sel=sel, out=out[4]);\n     Mux(a=a[5],  b=b[5],  sel=sel, out=out[5]);\n     Mux(a=a[6],  b=b[6],  sel=sel, out=out[6]);\n     Mux(a=a[7],  b=b[7],  sel=sel, out=out[7]);\n     Mux(a=a[8],  b=b[8],  sel=sel, out=out[8]);\n     Mux(a=a[9],  b=b[9],  sel=sel, out=out[9]);\n     Mux(a=a[10], b=b[10], sel=sel, out=out[10]);\n     Mux(a=a[11], b=b[11], sel=sel, out=out[11]);\n     Mux(a=a[12], b=b[12], sel=sel, out=out[12]);\n     Mux(a=a[13], b=b[13], sel=sel, out=out[13]);\n     Mux(a=a[14], b=b[14], sel=sel, out=out[14]);\n     Mux(a=a[15], b=b[15], sel=sel, out=out[15]);\n}`;\n","export const sol = `CHIP Mux4Way16 {\n    IN a[16], b[16], c[16], d[16], sel[2];\n    OUT out[16];\n\n    PARTS:\n    Mux16(a=a,  b=b,  sel=sel[0], out=ab);\n    Mux16(a=c,  b=d,  sel=sel[0], out=cd);\n    Mux16(a=ab, b=cd, sel=sel[1], out=out);\n\n// Alternate implementation\n//\n// Some students make a Mux4Way chip and apply it 16 times as in Not16.\n}`;\n","export const sol = `CHIP Mux8Way16 {\n    IN a[16], b[16], c[16], d[16],\n       e[16], f[16], g[16], h[16],\n       sel[3];\n    OUT out[16];\n\n    PARTS:\n    // Binary tree of 2-way multiplexors\n    Mux16 (a=a,    b=b,    sel=sel[0], out=ab);\n    Mux16 (a=c,    b=d,    sel=sel[0], out=cd);\n    Mux16 (a=e,    b=f,    sel=sel[0], out=ef);\n    Mux16 (a=g,    b=h,    sel=sel[0], out=gh);\n    Mux16 (a=ab,   b=cd,   sel=sel[1], out=abcd);\n    Mux16 (a=ef,   b=gh,   sel=sel[1], out=efgh);\n    Mux16 (a=abcd, b=efgh, sel=sel[2], out=out);\n\n\n// Alternate implementation\n//\n// This implementation replaces the upper two layers of the\n// tree with 4-way multiplexors.\n/*\n    Mux4Way16 (a=a, b=b, c=c, d=d, sel=sel[0..1], out=abcd);\n    Mux4Way16 (a=e, b=f, c=g, d=h, sel=sel[0..1], out=efgh);\n    Mux16     (a=abcd, b=efgh, sel=sel[2], out=out);\n*/\n\n// Alternate implementation\n//\n// Some students make a Mux8Way chip and apply it 16 times as in Not16.\n}`;\n","export const sol = `CHIP DMux4Way {\n    IN in, sel[2];\n    OUT a, b, c, d;\n\n    PARTS:\n    DMux (in=in, sel=sel[1], a=ab, b=cd);\n    DMux (in=ab, sel=sel[0], a=a, b=b);\n    DMux (in=cd, sel=sel[0], a=c, b=d);\n\n// Alternate implementation, using a canonical representation.\n/*\n    Not (in=sel[0], out=notSel0);\n    Not (in=sel[1], out=notSel1);\n    And (a=notSel1, b=notSel0, out=selA);\n    And (a=notSel1, b=sel[0],  out=selB);\n    And (a=sel[1],  b=notSel0, out=selC);\n    And (a=sel[1],  b=sel[0],  out=selD);\n    And (a=selA, b=in, out=a);\n    And (a=selB, b=in, out=b);\n    And (a=selC, b=in, out=c);\n    And (a=selD, b=in, out=d);\n*/\n}`;\n","export const sol = `CHIP DMux8Way {\n    IN in, sel[3];\n    OUT a, b, c, d, e, f, g, h;\n\n    PARTS:\n    // Binary tree of demultiplexors.\n    DMux (sel=sel[2], in=in,   a=abcd, b=efgh);\n    DMux (sel=sel[1], in=abcd, a=ab,   b=cd);\n    DMux (sel=sel[1], in=efgh, a=ef,   b=gh);\n    DMux (sel=sel[0], in=ab,   a=a,    b=b);\n    DMux (sel=sel[0], in=cd,   a=c,    b=d);\n    DMux (sel=sel[0], in=ef,   a=e,    b=f);\n    DMux (sel=sel[0], in=gh,   a=g,    b=h);\n\n// Alternate implementation\n//\n// Replace the final two layers of the binary tree with\n// 4-way demultiplexors.\n/*\n    DMux     (sel=sel[2],    in=in,   a=abcd,   b=efgh);\n    DMux4Way (sel=sel[0..1], in=abcd, a=a, b=b, c=c, d=d);\n    DMux4Way (sel=sel[0..1], in=efgh, a=e, b=f, c=g, d=h);\n*/\n\n// Alternate implementation\n//\n// The binary tree of demultiplexors implementation with\n// the demultiplexors in canonical form.\n/*\n    Not (in=sel[0], out=notSel0);\n    Not (in=sel[1], out=notSel1);\n    Not (in=sel[2], out=notSel2);\n\n    And (a=in,   b=notSel2, out=abcd);\n    And (a=in,   b=sel[2],  out=efgh);\n\n    And (a=abcd, b=notSel1, out=ab);\n    And (a=abcd, b=sel[1],  out=cd);\n    And (a=efgh, b=notSel1, out=ef);\n    And (a=efgh, b=sel[1],  out=gh);\n\n    And (a=ab,   b=notSel0, out=a);\n    And (a=ab,   b=sel[0],  out=b);\n    And (a=cd,   b=notSel0, out=c);\n    And (a=cd,   b=sel[0],  out=d);\n    And (a=ef,   b=notSel0, out=e);\n    And (a=ef,   b=sel[0],  out=f);\n    And (a=gh,   b=notSel0, out=g);\n    And (a=gh,   b=sel[0],  out=h);\n*/\n}`;\n","export const sol = `CHIP Or8Way {\n    IN in[8];\n    OUT out;\n\n    PARTS:\n    Or (a=in[0], b=in[1], out=or01);\n    Or (a=in[2], b=in[3], out=or23);\n    Or (a=in[4], b=in[5], out=or45);\n    Or (a=in[6], b=in[7], out=or67);\n    Or (a=or01, b=or23, out=or0123);\n    Or (a=or45, b=or67, out=or4567);\n    Or (a=or0123, b=or4567, out=out);\n}`;\n","export const sol = `CHIP HalfAdder {\n    IN a, b;    // 1-bit inputs\n    OUT sum,    // Right bit of a + b \n        carry;  // Left bit of a + b\n\n    PARTS:\n    Xor (a=a, b=b, out=sum);\n    And (a=a, b=b, out=carry);\n}`;\n","import { FileSystem, reset } from \"@davidsouther/jiffies/lib/esm/fs.js\";\n\nimport * as HalfAdder from \"./01_half_adder.js\";\nimport * as FullAdder from \"./02_full_adder.js\";\nimport * as Add16 from \"./03_add16.js\";\nimport * as Inc16 from \"./04_inc16.js\";\nimport * as Alu from \"./05_alu_no_stat.js\";\nimport * as AluStatus from \"./06_alu.js\";\n\nexport const SOLS = {\n  HalfAdder: {\n    \"HalfAdder.hdl\": HalfAdder.sol,\n  },\n  FullAdder: {\n    \"FullAdder.hdl\": FullAdder.sol,\n  },\n  Add16: {\n    \"Add16.hdl\": Add16.sol,\n  },\n  Inc16: {\n    \"Inc16.hdl\": Inc16.sol,\n  },\n  AluNoStat: {\n    \"AluNoStat.hdl\": Alu.sol,\n  },\n  ALU: {\n    \"ALU.hdl\": AluStatus.sol,\n  },\n};\n\nexport async function loadSolutions(fs: FileSystem): Promise<void> {\n  await fs.pushd(\"/projects/02\");\n  await reset(fs, SOLS);\n  await fs.popd();\n}\n","export const sol = `CHIP FullAdder {\n    IN a, b, c;  // 1-bit inputs\n    OUT sum,     // Right bit of a + b + c\n        carry;   // Left bit of a + b + c\n\n    PARTS:\n    HalfAdder (a=a, b=b, sum=sum1, carry=carry1);\n    HalfAdder (a=c, b=sum1, sum=sum, carry=carry2);\n    Or        (a=carry1, b=carry2, out=carry);\n\n// Alternate implementation.\n// The first implementation is the way FullAdder is described in the book.\n// This implementation is elegant, but slightly less efficient. There is\n// no reason to prefer either implementation over the other.\n/*\n    HalfAdder (a=a, b=b, sum=sum1, carry=carry1);\n    HalfAdder (a=c, b=sum1, sum=sum, carry=carry2);\n    HalfAdder (a=carry1, b=carry2, out=carry);\n*/\n\n// Alternate implementation using less abstraction.\n// Direct implementation without using half-adders,\n// as mentioned in the book.\n/*\n    Xor (a=a, b=b, out=abSum);\n    And (a=a, b=b, out=abCarry);\n    Xor (a=abSum, b=c, out=sum);\n    And (a=abSum, b=c, out=abcCarry);\n    Or  (a=abCarry, b=abcCarry, out=carry);\n*/\n}`;\n","export const sol = `CHIP Add16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    FullAdder (a=a[0],  b=b[0],         sum=out[0],  carry=c1);\n    FullAdder (a=a[1],  b=b[1],  c=c1,  sum=out[1],  carry=c2);\n    FullAdder (a=a[2],  b=b[2],  c=c2,  sum=out[2],  carry=c3);\n    FullAdder (a=a[3],  b=b[3],  c=c3,  sum=out[3],  carry=c4);\n    FullAdder (a=a[4],  b=b[4],  c=c4,  sum=out[4],  carry=c5);\n    FullAdder (a=a[5],  b=b[5],  c=c5,  sum=out[5],  carry=c6);\n    FullAdder (a=a[6],  b=b[6],  c=c6,  sum=out[6],  carry=c7);\n    FullAdder (a=a[7],  b=b[7],  c=c7,  sum=out[7],  carry=c8);\n    FullAdder (a=a[8],  b=b[8],  c=c8,  sum=out[8],  carry=c9);\n    FullAdder (a=a[9],  b=b[9],  c=c9,  sum=out[9],  carry=c10);\n    FullAdder (a=a[10], b=b[10], c=c10, sum=out[10], carry=c11);\n    FullAdder (a=a[11], b=b[11], c=c11, sum=out[11], carry=c12);\n    FullAdder (a=a[12], b=b[12], c=c12, sum=out[12], carry=c13);\n    FullAdder (a=a[13], b=b[13], c=c13, sum=out[13], carry=c14);\n    FullAdder (a=a[14], b=b[14], c=c14, sum=out[14], carry=c15);\n    FullAdder (a=a[15], b=b[15], c=c15, sum=out[15]);\n\n// Alternate implementation\n// Both implementations are described in the text. There is no reason\n// to prefer either implementation over the other.\n/*\n    FullAdder (a=a[0],  b=b[0],  c=false, sum=out[0],  carry=c0);\n    FullAdder (a=a[1],  b=b[1],  c=c0,    sum=out[1],  carry=c1);\n    ...\n*/\n}`;\n","export const sol = `CHIP Inc16 {\n    IN in[16];\n    OUT out[16];\n\n    PARTS:\n    Add16 (a=in, b[0]=true, b[1..15]=false, out=out);\n    \n// Alternative implementation. Unset bits are explicitly false.\n// Add16 (a=in, b[0]=true, out=out);\n\n// Alternate implementation using less abstraction.\n// The first implementation is how Inc16 is described in the text.\n// This is the classical implementation. \n/*\n    HalfAdder (a=in[0], b=true, sum=out[0],  carry=c0);\n    HalfAdder (a=in[1], b=c0,   sum=out[1],  carry=c1);\n    HalfAdder (a=in[2], b=c1,   sum=out[2],  carry=c2);\n    HalfAdder (a=in[3], b=c2,   sum=out[3],  carry=c3);\n    HalfAdder (a=in[4], b=c3,   sum=out[4],  carry=c4);\n    HalfAdder (a=in[5], b=c4,   sum=out[5],  carry=c5);\n    HalfAdder (a=in[6], b=c5,   sum=out[6],  carry=c6);\n    HalfAdder (a=in[7], b=c6,   sum=out[7],  carry=c7);\n    HalfAdder (a=in[8], b=c7,   sum=out[8],  carry=c8);\n    HalfAdder (a=in[9], b=c8,   sum=out[9],  carry=c9);\n    HalfAdder (a=in[10],b=c9,   sum=out[10], carry=c10);\n    HalfAdder (a=in[11],b=c10,  sum=out[11], carry=c11);\n    HalfAdder (a=in[12],b=c11,  sum=out[12], carry=c12);\n    HalfAdder (a=in[13],b=c12,  sum=out[13], carry=c13);\n    HalfAdder (a=in[14],b=c13,  sum=out[14], carry=c14);\n    HalfAdder (a=in[15],b=c14,  sum=out[15]);\n*/\n}`;\n","export const sol = `CHIP ALU {\n    IN  \n        x[16], y[16],  // 16-bit inputs        \n        zx, // zero the x input?\n        nx, // negate the x input?\n        zy, // zero the y input?\n        ny, // negate the y input?\n        f,  // compute out = x + y (if 1) or x & y (if 0)\n        no; // negate the out output?\n\n    OUT \n        out[16]; // 16-bit output\n\n    PARTS:\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out=out);\n    // x input processing, controlled by the 'zx' and 'nx' bits.\n    // When 'zx' is false, x is zeroed. 'nx' will select the negation of the\n    // possibly zeroed x input, and make it avaialble as 'xbus'.\n    Mux16 (sel=zx, a=x, b=false, out=xzero); \n    Not16 (in=xzero, out=notx);       \n    Mux16 (sel=nx, a=xzero, b=notx, out=xbus);\n\n    // y input processing, controlled by the 'zy' and 'ny' bits.\n    // When 'zy' is false, y is zeroed. 'ny' will select the negation of the\n    // possibly zeroed y input, and make it avaialble as 'ybus'.\n    Mux16(sel=zy, a=y, b=false, out=yzero);\n    Not16(in=yzero, out=noty);\n    Mux16(sel=ny, a=yzero, b=noty, out=ybus);\n\n    // Compute both functions and select based on the 'f' bit\n    And16(a=xbus, b=ybus, out=fbusand);\n    Add16(a=xbus, b=ybus, out=fbusadd);\n    Mux16(sel=f, a=fbusand, b=fbusadd, out=outbus);\n\n    // Output inversion, controlled by the 'no' bit\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out=out);\n}`;\n","export const sol = `CHIP ALU {\n    IN  \n        x[16], y[16],  // 16-bit inputs        \n        zx, // zero the x input?\n        nx, // negate the x input?\n        zy, // zero the y input?\n        ny, // negate the y input?\n        f,  // compute out = x + y (if 1) or x & y (if 0)\n        no; // negate the out output?\n\n    OUT \n        out[16], // 16-bit output\n        zr, // 1 if (out == 0), 0 otherwise\n        ng; // 1 if (out < 0),  0 otherwise\n\n    PARTS:\n    // x input processing, controlled by the 'zx' and 'nx' bits.\n    // When 'zx' is false, x is zeroed. 'nx' will select the negation of the\n    // possibly zeroed x input, and make it avaialble as 'xbus'.\n    Mux16 (sel=zx, a=x, b=false, out=xzero); \n    Not16 (in=xzero, out=notx);       \n    Mux16 (sel=nx, a=xzero, b=notx, out=xbus);\n\n    // y input processing, controlled by the 'zy' and 'ny' bits.\n    // When 'zy' is false, y is zeroed. 'ny' will select the negation of the\n    // possibly zeroed y input, and make it avaialble as 'ybus'.\n    Mux16(sel=zy, a=y, b=false, out=yzero);\n    Not16(in=yzero, out=noty);\n    Mux16(sel=ny, a=yzero, b=noty, out=ybus);\n\n    // Compute both functions and select based on the 'f' bit\n    And16(a=xbus, b=ybus, out=fbusand);\n    Add16(a=xbus, b=ybus, out=fbusadd);\n    Mux16(sel=f, a=fbusand, b=fbusadd, out=outbus);\n\n    // Output inversion, controlled by the 'no' bit\n    // 'out' bit 15 is the 'ng' flag\n    Not16(in=outbus, out=notoutbus);\n    Mux16(sel=no, a=outbus, b=notoutbus, out[15]=ng, out[0..7]=zr1, out[8..15]=zr2, out=out);\n\n    // Compute the zr and nz flags\n    Or8Way(in=zr1, out=zra);\n    Or8Way(in=zr2, out=zrb);\n    Or(a=zra, b=zrb, out=zror);\n    Not(in=zror, out=zr);\n}`;\n","export const sol = `CHIP Bit {\n    IN in, load;\n    OUT out;\n\n    PARTS:\n    \n    Mux (a=dffOut, b=in, sel=load, out=muxOut);\n    DFF (in=muxOut, out=dffOut, out=out);\n}`;\n","import { FileSystem, reset } from \"@davidsouther/jiffies/lib/esm/fs.js\";\n\nimport * as Bit from \"./01_bit.js\";\nimport * as Register from \"./02_register.js\";\nimport * as PC from \"./03_pc.js\";\nimport * as RAM8 from \"./04_ram8.js\";\nimport * as RAM64 from \"./05_ram64.js\";\nimport * as RAM512 from \"./06_ram512.js\";\nimport * as RAM4k from \"./07_ram4k.js\";\nimport * as RAM16k from \"./08_ram16k.js\";\n\nexport const SOLS = {\n  Bit: {\n    \"Bit.hdl\": Bit.sol,\n  },\n  Register: {\n    \"Register.hdl\": Register.sol,\n  },\n  PC: {\n    \"PC.hdl\": PC.sol,\n  },\n  RAM8: {\n    \"RAM8.hdl\": RAM8.sol,\n  },\n  RAM64: {\n    \"RAM64.hdl\": RAM64.sol,\n  },\n  RAM512: {\n    \"RAM512.hdl\": RAM512.sol,\n  },\n  RAM4k: {\n    \"RAM4k.hdl\": RAM4k.sol,\n  },\n  RAM16k: {\n    \"RAM16k.hdl\": RAM16k.sol,\n  },\n};\n\nexport async function loadSolutions(fs: FileSystem): Promise<void> {\n  await fs.pushd(\"/projects/03\");\n  await reset(fs, SOLS);\n  await fs.popd();\n}\n","export const sol = `CHIP Register {\n    IN in[16], load;\n    OUT out[16];\n\n    PARTS:\n    Bit (in=in[0],  load=load, out=out[0]);\n    Bit (in=in[1],  load=load, out=out[1]);\n    Bit (in=in[2],  load=load, out=out[2]);\n    Bit (in=in[3],  load=load, out=out[3]);\n    Bit (in=in[4],  load=load, out=out[4]);\n    Bit (in=in[5],  load=load, out=out[5]);\n    Bit (in=in[6],  load=load, out=out[6]);\n    Bit (in=in[7],  load=load, out=out[7]);\n    Bit (in=in[8],  load=load, out=out[8]);\n    Bit (in=in[9],  load=load, out=out[9]);\n    Bit (in=in[10], load=load, out=out[10]);\n    Bit (in=in[11], load=load, out=out[11]);\n    Bit (in=in[12], load=load, out=out[12]);\n    Bit (in=in[13], load=load, out=out[13]);\n    Bit (in=in[14], load=load, out=out[14]);\n    Bit (in=in[15], load=load, out=out[15]);\n}`;\n","export const sol = `CHIP PC {\n    IN in[16], load, inc, reset;\n    OUT out[16];\n\n    PARTS:\n    // The internal 'self' pin tracks the current state of the PC. The 'pc' pin\n    // tracks the next value of the PC. Based on 'inc', 'lost', and 'reset',\n    // one of 'self', 'pc', and 'false' will be put on 'next' and used as the\n    // input value of the Register, which will always load that value and write\n    // its current value to 'self'.\n\n    Inc16 (in=self, out=pc);\n\n    Mux16 (sel=inc,   a=self, b=pc,    out=pin0);\n    Mux16 (sel=load,  a=pin0, b=in,    out=pin1);\n    Mux16 (sel=reset, a=pin1, b=false, out=next);\n\n    Register (in=next, load=true, out=out, out=self);\n}`;\n","export const sol = `CHIP RAM8 {\n    IN in[16], load, address[3];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address,\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The registers proper\n    Register (in=in, load=load1, out=reg1);\n    Register (in=in, load=load2, out=reg2);\n    Register (in=in, load=load3, out=reg3);\n    Register (in=in, load=load4, out=reg4);\n    Register (in=in, load=load5, out=reg5);\n    Register (in=in, load=load6, out=reg6);\n    Register (in=in, load=load7, out=reg7);\n    Register (in=in, load=load8, out=reg8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=reg1,\n        b=reg2,\n        c=reg3,\n        d=reg4,\n        e=reg5,\n        f=reg6,\n        g=reg7,\n        h=reg8,\n        sel=address,\n        out=out\n    );\n}`;\n","export const sol = `CHIP RAM64 {\n    IN in[16], load, address[6];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[3..5],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The child blocks\n    RAM8 (in=in, load=load1, address=address[0..2], out=ram1);\n    RAM8 (in=in, load=load2, address=address[0..2], out=ram2);\n    RAM8 (in=in, load=load3, address=address[0..2], out=ram3);\n    RAM8 (in=in, load=load4, address=address[0..2], out=ram4);\n    RAM8 (in=in, load=load5, address=address[0..2], out=ram5);\n    RAM8 (in=in, load=load6, address=address[0..2], out=ram6);\n    RAM8 (in=in, load=load7, address=address[0..2], out=ram7);\n    RAM8 (in=in, load=load8, address=address[0..2], out=ram8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        e=ram5,\n        f=ram6,\n        g=ram7,\n        h=ram8,\n        sel=address[3..5],\n        out=out\n    );\n}`;\n","export const sol = `CHIP RAM512 {\n    IN in[16], load, address[9];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[6..8],\n        a=loada,\n        b=loadb,\n        c=loadc,\n        d=loadd,\n        e=loade,\n        f=loadf,\n        g=loadg,\n        h=loadh\n    );\n\n    // The child blocks\n    RAM64 (in=in, load=loada, address=address[0..5], out=rama);\n    RAM64 (in=in, load=loadb, address=address[0..5], out=ramb);\n    RAM64 (in=in, load=loadc, address=address[0..5], out=ramc);\n    RAM64 (in=in, load=loadd, address=address[0..5], out=ramd);\n    RAM64 (in=in, load=loade, address=address[0..5], out=rame);\n    RAM64 (in=in, load=loadf, address=address[0..5], out=ramf);\n    RAM64 (in=in, load=loadg, address=address[0..5], out=ramg);\n    RAM64 (in=in, load=loadh, address=address[0..5], out=ramh);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=rama,\n        b=ramb,\n        c=ramc,\n        d=ramd,\n        e=rame,\n        f=ramf,\n        g=ramg,\n        h=ramh,\n        sel=address[6..8],\n        out=out\n    );\n}`;\n","export const sol = `CHIP RAM4K {\n    IN in[16], load, address[12];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 8 load channels\n    DMux8Way(\n        in=load,\n        sel=address[9..11],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4,\n        e=load5,\n        f=load6,\n        g=load7,\n        h=load8\n    );\n\n    // The child blocks\n    RAM512 (in=in, load=load1, address=address[0..8], out=ram1);\n    RAM512 (in=in, load=load2, address=address[0..8], out=ram2);\n    RAM512 (in=in, load=load3, address=address[0..8], out=ram3);\n    RAM512 (in=in, load=load4, address=address[0..8], out=ram4);\n    RAM512 (in=in, load=load5, address=address[0..8], out=ram5);\n    RAM512 (in=in, load=load6, address=address[0..8], out=ram6);\n    RAM512 (in=in, load=load7, address=address[0..8], out=ram7);\n    RAM512 (in=in, load=load8, address=address[0..8], out=ram8);\n\n    // The output logic is a simple muxer\n    Mux8Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        e=ram5,\n        f=ram6,\n        g=ram7,\n        h=ram8,\n        sel=address[9..11],\n        out=out\n    );\n}`;\n","export const sol = `CHIP RAM16K {\n    IN in[16], load, address[14];\n    OUT out[16];\n\n    PARTS:\n    // Demux the address to the 4 load channels\n    DMux4Way(\n        in=load,\n        sel=address[12..13],\n        a=load1,\n        b=load2,\n        c=load3,\n        d=load4\n    );\n\n    // The child blocks\n    RAM4K (in=in, load=load1, address=address[0..11], out=ram1);\n    RAM4K (in=in, load=load2, address=address[0..11], out=ram2);\n    RAM4K (in=in, load=load3, address=address[0..11], out=ram3);\n    RAM4K (in=in, load=load4, address=address[0..11], out=ram4);\n\n    // The output logic is a simple muxer\n    Mux4Way16(\n        a=ram1,\n        b=ram2,\n        c=ram3,\n        d=ram4,\n        sel=address[12..13],\n        out=out\n    );\n}`;\n","export const sol = `CHIP Memory {\n    IN in[16], load, address[15];\n    OUT out[16];\n\n    PARTS:\n    DMux4Way (in=load, sel=address[13..14], a=load0, b=load1, c=loadScreen);\n    Or       (a=load0, b=load1, out=loadRAM);\n    RAM16K   (in=in, load=loadRAM, address=address[0..13], out=ramOut);\n    Screen   (in=in, load=loadScreen, address=address[0..12], out=screenOut);\n\n    // check if keyboard address - 0x6000 = 110 0000 0000 0000\n    And    (a=address[13], b=address[14], out=and1314);\n    Or8Way (in=address[0..7], out=or0to7);\n    Or8Way (in=address[5..12], out=or5to12);\n    Or     (a=or0to7, b=or5to12, out=or0to12);\n    Not    (in=or0to12, out=zero0to12);\n    And    (a=zero0to12, b=and1314, out=keyAddress);\n\n    // if keyboard address, output keyboard contents\n    Keyboard  (out=key);\n    Mux16     (a=false, b=key, sel=keyAddress, out=keyOut);\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n\n// Alternate implementation for keyboard decoding.\n/*\n    // check if keyboard address - 0x6000 = 110 0000 0000 0000\n    // The output Mux4Way16 selects the range 0x6000 - 0x7FFF (the 1's). \n    // Decode xx0 0000 0000 0000 so that only 0x6000 responds within\n    // this range.\n    Or8Way (in=address[0..7], out=or0to7);\n    Or8Way (in[0]=or0to7, in[1..7]=address[6..12], out=or0to12);\n    Not (in=or0to12, out=keyAddress);\n\n    // if keyboard address, output keyboard contents\n    Keyboard (out=key);\n    Mux16 (a=false, b=key, sel=keyAddress, out=keyOut);\n\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n*/\n\n\n// Alternate implementation.\n//\n// The book says \"Access to any address>24576 (0x6000) is invalid.\"  It can be\n// argued that any access to an invalid address may return a don't-care value.\n// The current keyboard value is as good a don't-care as any, so there is no\n// need to decode the specific address.\n//\n// Some argue that this is poor engineering practice.\n// Fully decoding I/O addresses should be encouraged.\n/*\n    PARTS:\n    DMux4Way (in=load, sel=address[13..14], a=load0, b=load1, c=loadScreen);\n    Or (a=load0, b=load1, out=loadRAM);\n    RAM16K (in=in, load=loadRAM, address=address[0..13], out=ramOut);\n    Screen (in=in, load=loadScreen, address=address[0..12], out=screenOut);\n    Keyboard (out=keyOut);\n    Mux4Way16 (a=ramOut, b=ramOut, c=screenOut, d=keyOut, sel=address[13..14], out=out);\n*/\n}`;\n","import { FileSystem, reset } from \"@davidsouther/jiffies/lib/esm/fs.js\";\n\nimport * as Memory from \"./01_memory.js\";\nimport * as CPU from \"./02_cpu.js\";\nimport * as Computer from \"./03_computer.js\";\n\nexport const SOLS = {\n  Memory: {\n    \"Memory.hdl\": Memory.sol,\n  },\n  CPU: {\n    \"CPU.hdl\": CPU.sol,\n  },\n  Computer: {\n    \"Computer.hdl\": Computer.sol,\n  },\n};\n\nexport async function loadSolutions(fs: FileSystem): Promise<void> {\n  await fs.pushd(\"/projects/05\");\n  await reset(fs, SOLS);\n  await fs.popd();\n}\n","export const sol = `CHIP CPU {\n    IN  inM[16],         // M value input  (M = contents of RAM[A])\n        instruction[16], // Instruction for execution\n        reset;           // Signals whether to re-start the current\n                         // program (reset==1) or continue executing\n                         // the current program (reset==0).\n\n    OUT outM[16],        // M value output\n        writeM,          // Write to M? \n        addressM[15],    // Address in data memory (of M)\n        pc[15];          // address of next instruction\n\n    PARTS:\n\n    // See Figure 5.9 for a schematic of the CPU.\n\n    // From figure 5.9, set all control bits from incoming instruction. \n    Not(in=instruction[15], out=aInstruction);\n    Mux16(\n        b=false,\n        a=instruction,\n        sel=aInstruction,\n        out[15]=cInst,\n        out[12]=a,\n        out[11]=c1,\n        out[10]=c2,\n        out[9]=c3,\n        out[8]=c4,\n        out[7]=c5,\n        out[6]=c6,\n        out[5]=d1,\n        out[4]=writeD,\n        out[3]=writeM,\n        out[0..2]=jump\n    );\n\n    // Register A will be filled from either the instruction line or the ALU,\n    // based on the aInstruction bit (bit 15 of the instruction).\n    Mux16(a=alu, b=instruction, sel=aInstruction, out=regA);\n\n    // Only read 15 bits of memory address into register A.\n    Or(a=aInstruction, b=d1, out=setA);\n    ARegister(in=regA, in[15]=false, load=setA, out[0..14]=addressM, out=A);\n\n    // D register is loaded from the ALU when d2 is set.\n    DRegister(in=alu, load=writeD, out=D);\n\n    // Fill the A bus line from either the A register or Memory, based on\n    // instruction bit a (12).\n    Mux16(a=A, b=inM, sel=a, out=AM);\n\n    // ALU control bits are mapped directly in C instructions when in c mode.\n    // If aInstruction is 0, c instructions are 0, and ALU will output 0.\n    ALU(\n        x=D,\n        y=AM,\n        zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6,\n        out=alu,\n        out=outM,\n        zr=zr, ng=ng\n    );\n    \n    // Jump\n    Not(in=ng, out=nng);\n    Not(in=zr, out=nzr);\n    And(a=nng, b=nzr, out=pt); // Positive is not negative and not zero\n\n    And(a=jump[2], b=ng, out=jlt);\n    And(a=jump[1], b=zr, out=jeq);\n    And(a=jump[0], b=pt, out=jgt);\n\n    And(a=jgt, b=jeq, out=jge);\n    And(a=jlt, b=jeq, out=jle);\n    And(a=jgt, b=jlt, out=jne);\n\n    Or8Way(\n        in[0]=jgt,\n        in[1]=jeq,\n        in[2]=jge,\n        in[3]=jlt,\n        in[4]=jne,\n        in[5]=jle,\n        out=jmpi,\n    );\n\n    And(a=jmpi, b=cInst, out=jmp);\n\n    PC(in=A, load=jmp, reset=reset, inc=true, out[0..14]=pc);\n}`;\n","export const sol = `CHIP Computer {\n    IN reset;\n\n    PARTS:\n    CPU(\n        reset=reset,\n        inM=outM,\n        instruction=instruction,\n        outM=inM,\n        writeM=writeM,\n        addressM=addressM,\n        pc=pc\n    );\n\n    // ROM\n    ROM32K(\n        address=pc,\n        out=instruction\n    );\n\n    // RAM\n    Memory(\n        in=inM,\n        load=writeM,\n        address=addressM,\n        out=outM\n    );\n}`;\n","import { FileSystem } from \"@davidsouther/jiffies/lib/esm/fs.js\";\n\nimport * as project_01 from \"./project_01/index.js\";\nimport * as project_02 from \"./project_02/index.js\";\nimport * as project_03 from \"./project_03/index.js\";\nimport * as project_05 from \"./project_05/index.js\";\n\nexport const ChipProjects = {\n  \"01\": project_01,\n  \"02\": project_02,\n  \"03\": project_03,\n  \"05\": project_05,\n};\n\nlet reset = false;\nexport const loadSolutions = async (fs: FileSystem) => {\n  if (reset) return; // React will double-render a call to resetFiles in useEffect.\n  reset = true;\n  await project_01.loadSolutions(fs);\n  await project_02.loadSolutions(fs);\n  await project_03.loadSolutions(fs);\n  await project_05.loadSolutions(fs);\n  reset = false;\n};\n\nexport const loaders = {\n  loadSolutions,\n};\n\nexport default loaders;\n"],"names":["SOLS","Not","And","Or","XOr","Mux","DMux","Not16","And16","Or16","Mux16","Mux4Way16","Mux8Way16","DMux4Way","DMux8Way","Or8Way","loadSolutions","fs","pushd","reset","popd","HalfAdder","FullAdder","Add16","Inc16","AluNoStat","ALU","Bit","Register","PC","RAM8","RAM64","RAM512","RAM4k","RAM16k","Memory","CPU","Computer","ChipProjects","project_01","project_02","project_03","project_05","loaders"],"sourceRoot":""}